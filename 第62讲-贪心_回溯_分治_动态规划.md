回溯
- 利用回溯求解八皇后问题

```js
function eight_queen() {
    const origin_arr = []
    // 生成八皇后地图
    for (let i = 0; i < 8; i ++) {
        origin_arr[i] = []
        for(let j = 0; j < 8; j ++) {
            origin_arr[i][j] = 0
        }
    }
    // 放置八皇后
    function put(row, put_queen){
        if (row === 8) return print(put_queen)
        for (let column = 0; column < 8; column ++) {
            if (isOk(put_queen, row, column)) {
                debugger
                put_queen[row][column] = 1
                put(row+1, JSON.parse(JSON.stringify(put_queen)))
            }
        }
    }
    // 判断是否能放
    function isOk(put_queen, r, c) {
        let prev = r-1
        for(let i = 0; i < c; i ++) {
            if(put_queen[r][i] === 1 && i !==c) {
                put_queen[r][i] = 0;
            }
        }
        while(prev >= 0) {
            if(!put_queen[prev][c] && !put_queen[prev][c-(r-prev)] && !put_queen[prev][c+(r-prev)]) {
                prev --
            } else {
                return false
            }
        }
        return true
    }

    function print(arr) {
        let str = ''
        for (let i = 0; i < arr.length; i ++) {
            str += '['
            for (let j = 0; j < arr[i].length; j ++) {
                str += arr[i][j] + (j === arr[i].length -1 ? '': ', ')
            }
            str += ']\n'
        }
        console.log(str)
    }
    put(0, Array.from(origin_arr))
}
eight_queen()

```
- 利用回溯求解0-1背包

```js
function bag01() {
    const things = [1,2,3,4,5,6,7,8,9,10,11,12,22,33,41]
    const bag_limit = 15
    let max = 0;
    const reduce_array = []
    function put(index, total_load, current_weight) {
        if (index === things.length) {
            return reduce_array.push(total_load)
        }
        put(index+1, Array.from(total_load), current_weight)
        if (current_weight + things[index] <= bag_limit) {
            if (current_weight + things[index] > max) {
                max = current_weight + things[index]
            }
            total_load.push(things[index])
            current_weight += things[index]
            put(index + 1, Array.from(total_load), current_weight)
        }
    }
    put(0, [], 0)
    debugger
    reduce_array.forEach(ele => {if(ele.length && ele.reduce((a,b) => a+b) === max) console.log(ele)})
}
bag01()
```

分治
- 利用分治求一组数据的逆序对个数

动态规划
- 0-1背包问题
- 最小路径和
- 编程实现莱温斯坦最短编辑距离
- 编程实现查找两个字符串的最长公共子序列
- 编程实现一个数据序列的最长递增子序列