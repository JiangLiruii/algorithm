# 散列表

- 实现一个基于链表法解决冲突问题的散列表

```js
class Node {
    constructor(data) {
        this.data = data;
        this.next = null
    }
}
class HashMap {
    constructor() {
        this.origin_map = {}
        this.key = Math.random()
    }
    insert(data) {
        if (!this.origin_map[this.hash(data)]) {
            this.origin_map[this.hash(data)] = new Node(data)
        } else {
            let node = this.origin_map[this.hash(data)];
            while(node.next) {
                node = node.next
            }
            const new_node = new Node(data)
            node.next = new_node
        }
    }
    hash(data) {
        // key值控制在100以内, 散列表的长度为100
        return parseInt(this.key*data) % 100;
    }
    is_exist(data) {
        let node = this.origin_map[this.hash(data)]
        while(node) {
            if (node.data === data) {
                return true
            } else {
                node = node.next
            }
        }
        return false
    }
}
var m = new HashMap()
m.insert(123)
m.is_exist(123)
m.insert(122)
m.is_exist(122)
```

- 实现一个LRU缓存淘汰算法(Least Recently Used淘汰最久未使用的)

```js
// 先实现上述那样的链表散列表, 缓存都有个地址, 将地址hash化后存入对应的key中, 然后缓存还是用一整个双向链表来维护, 但是在查找,新增和删除的时候会快很多.
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
        this.prev = null;
        this.hnext = null;
        this.hprev = null;
    }
}
// 初始化头节点和尾节点
const head_node = new Node('head_node');
let tail_node = head_node;
class HashMap {
    constructor(size) {
        this.origin_map = {}
        this.key = Math.random()
        this.size = size;
        this.current_size = 0;
    }
    insert(data) {
        const new_node = new Node(data)
        if (!this.origin_map[this.hash(data)]) {
            this.origin_map[this.hash(data)] = new_node
            head_node.next
        } else {
            let node = this.origin_map[this.hash(data)];
            while(node.next) {
                node = node.next
            }
            // 更新hash链接
            new_node.hprev = node;
            node.hnext = new_node;
        }
        // 更新到链表头
        this.update_head(new_node)
        this.current_size ++;
    }
    update_head(node) {
        if (head_node.next) {
            // 如果超出大小限制, 更新tail_node
            if (this.current_size == this.size) {
                tail_node = tail_node.prev
                tail_node.next = null
            }
            const old_head = head_node.next
            head_node.next = node;
            node.prev = head_node;
            node.next = old_head
            old_head.prev = node;
        } else {
            head_node.next = node;
            node.prev = head_node;
            tail_node = node;
        }
    }
    hash(data) {
        // key值控制在100以内, 散列表的长度为100
        return parseInt(this.key*data) % 100;
    }
    is_exist(data) {
        let node = this.origin_map[this.hash(data)]
        while(node) {
            if (node.data === data) {
                return true
            } else {
                node = node.next
            }
        }
        return false
    }
    use_data(data) {
        let node = this.origin_map[hash(data)]
        if (!node) {
            return null
        } else {
            // 遍历查找data
            while(node && node.data !== data) {
                node = node.next
            }
            if(!node) return null
            // 有node, 更新缓存链表到头部
            this.update_head(node)
            return node
        }
    }
}

var a = new HashMap(10)
a.insert(123)
a.insert(122)
```

# 字符串

- 实现一个字符集, 只包含a-z这26个字母的Trie树

```js
function GenerateTrie() {
    const Trie = {};
    const arr = []
    for (let i = 0; i < 26; i++) {
        arr[i] = String.fromCharCode(97+i)
    }
    Trie['origin_arr'] = arr
    Trie['get_']
}