短网址服务可以将原始很长的网址转换成很短的网址, 访问两者都一样.访问短网址会自动重定向到原始网址

![](/img/short_website.jpg)

## 通过哈希算法生成短网址

MD5, SHA等, 因为不需要考虑反向解密的问题, 所以只用关心哈希算法的计算速度和冲突概率.

MurmurHash算法, 提供了两种长度的哈希值, 一种是32bits, 一种是128bits, 为了让最终生成的短网址尽可能的短, 选择32bits的哈希值.短网址中http://t.cn/181338494 后面的数字就是哈希值.

#### 1. 如何让短网址更短?

使用MurmurHash之后因为有一长串的数字, 好像还是很长. 所以需要稍微改变一下哈希值的表示方法, 把10进制的转换成更高的进制, 比如62进制0-9, a-z,A-Z, 共62个.最终上述的短网址就会被表示成http://t.cn/cgSqq, 计算过程为:

![](/img/short_website1.jpg)

#### 2. 如何解决哈希冲突的问题?

尽管冲突概率很低, 但一旦冲突会导致两个原始网站被转化成同一个短地址, 无从判断是哪一个了. 一般情况下会保存短网址跟原始网址的对应关系, 以便后续用户访问短网址时进行快速查找, 假设保存在MySQL中,

当有一个新的原始网站要生成短网址时, 利用Murmur Hash算法生成短网址, 然后在MySQL中进行查找, 如果没有找到相同的短网址, 说明没有冲突, 返回给用户, 如果有也不一定冲突, 要拿出来进行比对, 如果原始网址一样, 说明之前有人已经生成过了, 那么把这个返回给用户即可, 如果比对不一致,  就说明发生了冲突, 则可以加入一些特殊标识符,比如[DUPLICATED]到原始网址, 进行hash化, 返回短网址, 当请求短网址时, 拿到了原始网址之后要将特殊标识进行清除在返回给浏览器.

#### 3. 如何优化哈希算法生成短网址的性能
1. 减少MySQL的查询和添加次数, 将短网址设为唯一id, 直接跳过查询判重, 先插入, 插入出错后,再进行查询判重, 对短网址添加B+树索引, 可以覆盖90%的场景.
2. 使用布隆过滤器, 因为布隆过滤器是如果不存在一定不存在, 存在却不一定存在的逻辑, 可以先过布隆, 如果不存在直接插入, 存在, 则先进行查询判重.

除了这种对原始网址进行哈希的方法之外, 还有另外一种短网址的生成算法: 利用自增ID生成器生成短网址.比如维护1,2,3,,这样自增的生成器, 拼接到短网址http://t.cn/ 后面, 但是会出现两个问题

1. 同一个原始网址如果多次生成的化会有多个短地址.

有两种思路
   1. 不做处理, 短地址的精确性和唯一性并不是用户所关心的, 只要能跳到原始地址即可
   2. 借助哈希算法生成短网址, 先拿原始网址取数据库中进行查找, 如果有短网址, 直接返回给用户, 而不用进行重复生成.但是这样的话需要对原始网址和短网址都建立索引, 会占据更多的储存空间, 也会导致插入删除操作性能的下降.

2. 如何实现高性能的ID生成器
   1. 保证ID唯一性, 需要加锁, 使用前置发号器, 提高并发能力
   ![](/img/short_website2.jpg)
   2. 使用多个ID生成器, 相互独立不重复
   ![](/img/short_website3.jpg)


