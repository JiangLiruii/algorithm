# 最好, 最坏, 平均, 均摊复杂度分析

## 除了之前讲的空间和时间复杂度之外还有四种复杂度. 直接看例子
```js
function calc(arr) {
  for (let i in arr) {
    if (arr[i] === i) {
      return i;
    }
  }
  return -1
}
```
## 上述代码很简单, 就是找到一个数组中第一个值与索引相同的那个量. 下面来分析这个的复杂度

- 最好复杂度

如果第一个就满足要求, 那么复杂度就是 O(1)

- 最坏复杂度

如果都不满足要求, 那么就要遍历全部, 也就是 O(n)

- 平均复杂度

一共有 n + 1 种可能性(加一是包含所有值都不满足的情况), 所有可能性的复杂度的和为: (1+n)*n / 2 + n = n * (n + 3) / 2

那么平均复杂度为: n * (n + 3) / (2 *(n + 1)), 简化成大 O 就是 O(n), 但是这里有个问题是没有将概率考虑进去, 有还是没有这个概率是1/2, 有的情况下, 出现在每一个的情况是1/n, 所以将概率考虑进去的结果就是:

(1+2+3+4....+n) * 1/2n + n * 1/2 = (1+3n) / 4 结果还是 O(n)

- 均摊复杂度

均摊复杂度的本质是看不同情况的复杂度是否可以均摊, 比如:

```js
let count = 0
let arr = new Array(n)// 表示 n 位数组
function insert(val) {
  if (count === arr.length) {
    let sum = 0;
    for (let i of arr) {
      sum += i
    }
    arr[0] = sum;
    count = 1;
    return;
  }
  count ++;
  arr[count] = val;
}
```
上述代码的意思是: 向数组中插入值, 如果数组插满了就将数组的第一个值设为数组元素的和, 然后再从第一个开始插.

### 最好复杂度: 
不会遍历, 复杂度为O(1)
### 最坏复杂度: 
会遍历, 复杂度为 O(n)
### 平均复杂度: 
每一个的概率是1/n,前 n-1个复杂度都是1, 第 n 个为 n, 所以平均复杂度为:
(1/n+1/n) * (n-1) / 2 + n * 1/n = (3n-1) / n 为 O(1)

### 下面来分析它的均摊复杂度.

前n - 1 的每一次插入都是复杂度都是1, 只有当最后一个的时候(count = arr.length - 1)复杂度会变为 n, 循环往复, 那么这个复杂度就可以均摊到每一个复杂度为1的上面, 均摊下来复杂度就为 2, 即 O(1)

实际上不用很纠结均摊复杂度, 只是一种特殊的平均复杂度. 只在很有规律的循环往复的情况下可用.

下面再来个例子检验一下

```js
let arr = new Array(10) // 表示 10 位数组
let len = 10
let i = 0
function add(val) {
  if (i >= len) {
    new_arr = new Array(2 * len)
    for (let j in arr) {
      new_arr[j] = arr[j]
    }
    arr = new_arr
  }
  arr[i] = val
  len += 2
  i ++ 
}
```

该函数表达的意思是当 i 大于等于 len 的时候, 申请一个两倍的空间, 并将之前的值按照次序放入新的 arr 中, 再进行插入.

最好复杂度为: 不进入循环 O(1)
最坏复杂度为: 进入循环 O(n)
平均复杂度为:
每一个 add 的概率都为: 1/n, 前 n-1 次 add 的复杂度为1, 最后一个的复杂度为 n(不知道要不要算 arr[i] = val 这一行的复杂度, 如果算上应该是 n+1) 所以平均复杂度为:
(n-1) * 1/n + n * 1/n = (2*n-1) /n 即 O(1)
均摊复杂度为:
每 n 次一个循环, 最后一次的复杂度可以均摊到其余 n-1 次上, 所以均摊复杂度依然为 O(1).

但是老师, 我想问如果不是 n 次一个循环呢?还能均摊吗? 比如如果是3的倍数, 我就把数组遍历一遍, 每一个加1, 其余情况还是插入这个函数, 即变成:
```js
let arr = new Array(10) // 表示 10 位数组
let sum = 0
let i = 0
function add(val) {
  if (i % 3 || i > arr.length) {// 当 i 为3的倍数, 或者大于长度时
    new_arr = new Array(2 * len)
    for (let j in arr) {
      sum += arr[i]
    }
    arr[0] = sum
    if (i > arr.length) {
      i = 1
    } else {
      i ++
    }
  } else {
    arr[i] = val
    len += 2
    i ++ 
  }
}
```
这个还能均摊吗?
我认为不能, 比如, 第1,2次是复杂度是1, 第三次是2(遍历前两个插入的), 4,5次为1, 第6次为5, 后面凡是3的倍数的复杂度会越来越高, 但是可以均摊的却没有跟着增多, 也就是负责度在一直累加着, 所以, 当n 趋于无穷大的时候是不是就可以忽略均摊的部分了, 所以均摊的复杂度为 O(n),不知道这样想正不正确
