# 图

- 实现有向图, 无向图, 有权图, 无权图的邻接矩阵和邻接表的表示方法

- 无向图和有向图(无权)

![](img/graph_1.jpg)
```js
function get_matrix(graph) {
    let result = []
    for (let i = 0; i < graph.size; i ++) {
        for (let j = 0; j < graph.size; j ++) {
            if (graph.hasEdge(i,j) || graph.hasPointEdge(i,j)) {
                result[i] ? result[i][j] = 1 : (result[i] = [] && result[i][j] = 1)
            }
        }
    }
    return result
}
function get_adjacency(graph) {
    let result = []
    for (let i = 0; i < graph.size; i++) {
        for (let j = 0; j < graph.size; j ++) {
            if (graph.hasEdge(i,j)) {
                result[i] ? result[i].next = new Node(j) : result[i] = new Node(j)
            }
        }
    }
    return result
}
```
- 有权图

```js
function get_matrix(graph) {
    let result = [];
    for (let i = 0; i < graph.size; i ++) {
        for (let j = 0; j < graph.size; j++) {
            if (graph.hasEdge(i,j) || graph.hasPointEdge(i,j)) {
                result[i] ? result[i][j] = graph.getEdgeValue(i,j) : (result[i] = [] && result[i][j] = graph.getEdgeValue(i,j))
            }
        }
    }
    return result
}

```
- 实现图的深度优先搜索, 广度优先搜索

```js
function DFS(graph, s, t) {
    function find(vetex) {
        const queue = graph.findNext(vetex);
        for (let i = 0; i < queue.length; i++) {
            if (queue[i] === t) return 'found';
            find(queue[i])
        }
    }
    find(s)
}

function BFS(graph, s, t) {
    let queue = graph.findNext(s)
    while(queue.length) {
        const vertex = queue.pop()
        if (vertex === t) return 'found'
        queue = queue.concat(graph.findNext(vertex)) 
    }
}
```
- 实现Dijkstra算法, A*算法
- 实现拓扑排序的Kahn算法, DFS算法