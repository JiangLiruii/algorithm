回溯算法可以解决很多的问题, 比如数独, 八皇后, 0-1背包, 图的着色, 旅行商问题, 全排列等. 应用十分广泛

如何理解回溯, 其实就是发现一个选择错误之后回到上一次做选择的点. 就像电影"蝴蝶效应"一样.不停的回到以前做选择的地方, 重新修改选择而有不同的结果.

回溯的处理思想类似枚举搜索, 枚举所有的解, 找到满足期望的解. 为了有规律的枚举所有可能的解, 避免遗漏和重复, 把问题求解的过程分成多个节点, 每个阶段都穷举所有可能的选择, 当某条路走不通时, 回退到上一个选择处.

8皇后问题, 假设有8*8的棋盘, 希望放入8个皇后, 每一行每一列和斜对角线都不允许出现两个皇后, 请问该如何放置这8个皇后?

首先分成8个阶段, 每个阶段需要在一行内放一个皇后, 需要满足已定的要求

```js
// 下标表示行, 值表示列
const result = new Array(8);
cal8queens(0, Array.from(result))
function cal8queens(row, result) {
    if (row === 8) {
        print(result)
        return
    }
    for (let column = 0; column < 8; column ++) {
        if (isOk(row, column, result)) {
            result[row] = column // 第 row 行第 column 列有皇后
            cal8queens(row+1, Array.from(result))
        }
    }
}

function isOk(r, c, result) {
    let leftup = c - 1,rightup = c + 1
    for (let i = r - 1; i >= 0; i --) {
        if (result[i] === c) return false;
        if (leftup >= 0) {
            if (result[i] === leftup) {
                return false
            }
        }
        if (rightup <= 7) {
            if (result[i] === rightup) {
                return false
            }
        }
        leftup --;
        rightup ++;
    }
    return true
}

function print(res) {
    let res_str = '';
    for (let row = 0; row < 8; row ++) {
        for (let column = 0; column < 8; column ++) {
            res_str += (res[row] === column ? ' 1' : ' *');
            if (column === 7) {
                res_str += '\n'
            }
        }
    }
    console.log(res_str)
}
```
要注意几个点
- 一定要用 Array.from 传数组, 要不然都是改的同一个, 会有问题.
- 打印最终的结果的print方法
- isOk 的各种情况, 同列, 左对角线, 右对角线.