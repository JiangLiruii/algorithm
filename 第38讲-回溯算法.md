回溯算法可以解决很多的问题, 比如数独, 八皇后, 0-1背包, 图的着色, 旅行商问题, 全排列等. 应用十分广泛

如何理解回溯, 其实就是发现一个选择错误之后回到上一次做选择的点. 就像电影"蝴蝶效应"一样.不停的回到以前做选择的地方, 重新修改选择而有不同的结果.

回溯的处理思想类似枚举搜索, 枚举所有的解, 找到满足期望的解. 为了有规律的枚举所有可能的解, 避免遗漏和重复, 把问题求解的过程分成多个节点, 每个阶段都穷举所有可能的选择, 当某条路走不通时, 回退到上一个选择处.

8皇后问题, 假设有8*8的棋盘, 希望放入8个皇后, 每一行每一列和斜对角线都不允许出现两个皇后, 请问该如何放置这8个皇后?

首先分成8个阶段, 每个阶段需要在一行内放一个皇后, 需要满足已定的要求

```js

function eightQueen() {
    const row = 0
    let queen_in = []
    for (let i = 0; i < 8; i ++) {
        const ready_to_in = new Array(8)
        queen_in.push(ready_to_in)
    }
    putQueen(row)
    function putQueen(n) {
        debugger
        for (let i = 0; i < 8; i ++) {
            let can_put = true

            for (let j = n-1; j >= 0; j--) {
                // 对应的列有无皇后
                if (queen_in[j][i]) {
                    can_put = false
                }
                // 对应的左对角线有无皇后
                if ((i-(n-j)) >= 0 && queen_in[j][i-(n-j)]) {
                    can_put = false
                }
            }
            for(let j = n + 1; j < 8; j ++) {
                // 对应的列有无皇后
                if (queen_in[j][i]) {
                    can_put = false
                }
                // 对应的右对角线有无皇后
                if (i+j-n <= 7 && queen_in[j][i+j-n]) {
                    can_put = false
                }
            } 
            if(can_put && n < 8 ) {
                queen_in[n][i] = 1;
                console.log(n, i)
                if (n === 7) {
                    return console.log(queen_in)
                }
                return putQueen(n+1)
            }

        }
    }
}
eightQueen()

