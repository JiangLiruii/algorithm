# 之前有讲递归的时候分析过递归的复杂度, 如果用数学公式进行推导是比较复杂的. 如果借助树的结构(树也是从根节点到叶子节点的分解过程)来分析, 就会直观和简单很多

![](/img/recursive_tree.jpg)

## 上图是斐波拉契数列的分解求解过程, 一个节点的求解可以被分解为左右节点的求解.

![](img/merge_sort_tree.jpg)

## 上图为归并排序的分解过程, 如果假设每一次的分解所消耗的时间即为常量1, 归并操作消耗的时间即为 n, 现在只需要知道这个树的高度即可得到总的复杂度为 O(n*h), 归并排序的归并树为满二叉树, 满二叉树的高度大约为 log<sub>2</sub>n, 所以归并排序的复杂度大致为 O(nlogn), 这样分析的下来比使用递推公式直观很多.

## 实战1: 分析快排的复杂度

快排在最好情况下是每次分区都可以一分为二, 所以使用递推公式(这里使用 +n 是因为有一次数据的遍历) `T(n) = 2T(n/2) + n`, 这样可以推导出复杂度为 O(nlogn), 但是如果是不理想的情况, 每次分区不能一分为二, 如果分的比例是1:9, 那么递推公式为 `T(n) = T(n/10) + T(9*n/10) + n`

![](/img/quick_sort_tree.jpg)

