字符串匹配是很多语言中很常用的功能, 比如 js 中就有 indexof(), python 中也有 find()等, 这些底层依赖的就是字符串匹配算法

两种最简单也是最好理解的:

# BF(Brute Force) 算法
中文叫暴力匹配算法, 也叫朴素匹配算法. 非常简单, 但是代价是性能较低
**定义**
- 主串: 被搜索的字符串
- 模式串: 用来去匹配的字符串, 如果匹配成功即为主串的子字符串

## 思想
检查主串中的起始位置, 从 0 到 n-m, 且长度为 m 的 **n - m + 1** 个子串, 判断是否有匹配的

![](/img/BF_string.jpeg)

复杂度: 需要比对 n-m+1 次, 每次需要比对 m 次, 所以整个的复杂度为 O(m*n)

虽然复杂度很高, 但是确实比较常用的, 原因有两点
- 主串不会太长, 每次匹配的时候中途不匹配就会停下, 所以复杂度是肯定要比分析的低很多
- 简单, 不容易出错, 满足性能的情况下, 简单是首选(KISS KeepItSimpleAndStupid)

# RK(Rabin-Karp)算法
是由 Rabin 和 Karp 发明的算法. 可以看做 BF 的升级版

朴素算法的时候提到需要进行 n-m+1 次子串的匹配, 如果把这 n-m+1 个子串都用哈希值存起来, 然后再将模式串 hash 化, 最后只比较哈希值, 那么复杂度一下子就可以降到 n.

![](/img/RK_string.jpeg)

举个例子, 比如是比较英文字符, 那么可以用26进制来表示, 那么每个英文单词都会是唯一的值.可以类比十进制

![](/img/RK_string_1.jpeg)

但是有个问题, hash 化比较花时间, 因为如果 m 比较大的话, 需要计算26的m 次方, 如何减少这里的复杂度?

- 储存已计算的次方值, 即下述公式的26^m
- 利用前一次计算的结果, 比如:

![](/img/RK_string_2.jpeg)

两个相邻的子串 s[i-1] s[i], 两者的 hash 值分别为 h[i-1], h[i], 有如下的公式
`h[i] = 26*(h[i-1] - 26^(m-1)*(s[i-1] - 'a')) + (s[i+m-1] - 'a')`

复杂度:
- 遍历一次求得 hash 值, 复杂度为 n
- 每次比较复杂度为1
- 总共需要比较 n-m+1 次, 复杂度为 O(n-m+1)

**所以总的复杂度为 O(n)**

其实这里的 hash 表也会跟之前一样有散列冲突, 极端情况下, 会使复杂度退化到 O(n*m), 但这种情况很罕见.
- 再比较一下原始字符串即可. 
- 把位权设置为依次增大的素数

# 思考题
上述都是一维的字符串, 如果要使用二维的字符串矩阵呢?比如:

![](/img/RK_string_4.jpeg)

可以先查找第一行的字符串，假设长度为m，用bf或者rk都可以，假设是n*n的数组，
bf的复杂度是m * n
rk的复杂度为n

如果有匹配，则依次匹配第2到m行字符串。每次的复杂度与第一次的相同

最坏时间复杂度为
bf:n^2*n^2 = n^4
rk:n^2

但是如果第一行不匹配的话是不会进行第二行的匹配的，平均复杂度会小很多。
