# 二叉树

- 实现一个二叉查找树, 支持插入, 删除, 查找操作

```js
// 定义节点
class Node {
    constructor(data, parent) {
        this.data = data;
        this.right = null;
        this.left = null;
        this.parent = parent;
    }
}
class BiSearchTree {
    constructor(arr) {
        this.root = new Node(arr[1], null)
        let current_node = this.root
        this.arr = arr
        this.arrange()
    }
    arrange() {
        let index = 1
        let current_nodes = [this.root]
        this.arr[index] = this.root
        while (index < this.arr.length) {
            const new_current_nodes = []
            for (let i = 0; i < current_nodes.length; i++) {
                const current_node = current_nodes[i]
                if (this.arr[index+1]) {
                    current_node.left = new Node(this.arr[index+1], current_node);
                    this.arr[index+1] = current_node.left
                }
                if (this.arr[index+2]) {
                    current_node.right = new Node(this.arr[index+2], current_node);
                    this.arr[index+2] = current_node.right
                }
                index += 2;
                new_current_nodes.push(current_node.left, current_node.right)
            }
            current_nodes = new_current_nodes;
        }
    }
    insert(data) {
        const size = this.arr.length
        const last = this.arr[(size >> 1)];
        const new_node = new Node(data, last)
        if (!last.left) {
            last.left = new_node
        } else {
            last.right = new_node
        }
        this.arr.push(new_node)
        this.arrange()
    }
    find(data) {
        for(let index in this.arr) {
            console.log(this.arr[index])
            if(this.arr[index].data === data) return index;
        }
        return null
    }
    delete(data) {
        const index = this.find(data);
        if (!index) return 'no node to delete';
        this.arr.splice(index, 1)
        this.arrange()
    }
}
var a = [, 1,3,5,7,9,2,4,6,8,10]
var b = new BiSearchTree(a)
b.delete(3)
```
- 实现查找二叉查找树中某个节点的后继, 前驱节点
```js

```

- 实现二叉树前, 中, 后序以及按层遍历

```js
// 前序遍历
function pre_order(node) {
    console.log(node)
    node.left && pre_order(node.left)
    node.right && pre_order(node.right)
}
// 中序遍历
function mid_order(node) {
    node.left && mid_order(node.left)
    console.log(node)
    node.right && mid_order(node.right)
}
// 后续遍历
function post_order(node) {
    node.left && post_order(node.left)
    node.right && post_order(node.right)
    console.log(node)
}
// 按层遍历
function level_order(nodes_list) {
    const new_nodes = [];
    for (let node of node_list) {
        console.log(node)
        node.left && new_nodes.push(node.left)
        node.right && new_nodes.push(node.right)
    }
    level_order(new_nodes)
}
```

# 堆

- 实现一个小顶堆, 大顶堆, 优先级队列
- 实现堆排序
- 利用优先级队列合并K个有序数组
- 求一组动态数据集合的最大TopK