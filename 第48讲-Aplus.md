搜索: 如何用 A+搜索算法实现游戏中的寻路功能?

人物处于游戏地图中某个位置时, 鼠标点击距离较远的另外一个位置, 人物会自动绕过障碍物走过去. 这个功能如何实现?

这是一个典型的搜索问题: 人物起点-->当前位置, 人物终点-->鼠标点击位置. 需要在地图上找一条从起点到终点的路径, 这条路径需要绕过所有的障碍物, 还要走的不能太绕, 即走最短路径.

之前有说过使用 Dijkstra 来规划最短路径, 但是该算法之前已经说了比较耗时.在权衡路线质量和执行效率的情况下, 只需要寻求一个次优解就足够了.那么问题就转化为**如何寻求一条接近于最短路线的次优路线呢?**

## A+算法

Dijkstra 算法是盲目的, 他会遍历所有的邻接节点, 找到最小的那个, 然后再类似 BFS 的向下遍历.

![](/img/Dijkstra_short.jpeg)

比如上图就会先遍历 1,2,3, 跟从起点 s 到终点 t 的方向背道而驰. 是不是综合一下这个顶点距离终点可能还有多远考虑进去, 来判断哪个顶点该先出队列, 就可以避免跑偏了呢?

**启发函数(heuristic function)**: 当前顶点和终点的欧几里得距离, 记为h(i), 直线距离与路径长度是两个概念.
把从起点到当前顶点的路径长度记为 g(i)
**曼哈顿距离(Manhattan Distance)**: 欧几里得距离的改良, 不涉及平方和开根号, 两点之间横纵坐标的距离之和.
```js
function Manhattan(vertex1, vertex2) {
  return Math.abs(vertex1.x-vertex2.x)+Math.abs(vertex1.y-vertex2.y)
}
```

原来 Dijkstra 只单纯通过 g(i) 来估算最短路径长度, 现在加上 h(i), 即 f(i) = g(i)+h(i), f(i)被称为 **估价函数(evaluation function)**

实际上 A+算法就是对 Dijkstra 算法的简单改造, 引入了一个 **修正因子 h(i)**




