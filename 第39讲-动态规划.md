动态规划是很需要掌握的一种算法思想. 前面所讲的回溯其实可以通过"递归备忘录"的方法来优化复杂度, 实际上就跟动态规划的复杂度相差无几了, 比如0-1背包问题

```js
let already_max = 0
function bag_0_1(bag_max, put_list) {
    // 递归备忘录
    const record = new Array(put_list.length)
    for (let i = 0; i < put_list.length; i++) {
        record[i] = {}
    }
    put(0,0)
    function put(i, total_put) {
        if (i === put_list.length) {
            if (total_put > already_max) {
                already_max = total_put;
            }
            return;
        }
        const add_weight = total_put + put_list[i];
        debugger
        if (record[i][add_weight]) { console.log(11111);return;}
        record[i][add_weight] = true;
        if (add_weight <= bag_max) {
            put(i+1, add_weight)
        }
        put(i+1, total_put)
    }
}

bag_0_1(5, [2,2,4,3,5])
```

那么动态规划是怎么做的呢? 其本质上还是去找有无重复的子问题.

用一个二维数组state[][]来记录每一次放或不放的状态.比如
第0个物品的重量是2, 要么装入背包, 要么不装入背包, 背包中的物体状态只有两种: state[0][0] 或state[0][2]
第1个物品的重量也是2, 同样的逻辑, 背包中的物体状态有多少种呢? state[1][0] state[1][2] state[1][2] state[1][4] , 看到没, 有一个state[1][2]是重复的.所有就只有三种状态
以此类推 考察完所有的物品之后,整个states状态数组就计算完了.

![](/img/dynamic_plan.jpg)

```js
function bag_dynamic(max, things_list) {
    const n = things_list.length
    const result =  new Array(n);
    for(let i = 0; i < n; i ++) {
        result[i] = []
        for (let j = 0; j < max; j++) {
            result[i][j] = 0
        }
    }
    // 第一行特殊处理
    result[0][0] = true
    result[0][things_list[0]] = true
    function put_thing(index, total_load, max, n, result) {    
        for (let Index = 1; Index < n; Index++) {
            for (let i = 0; i < max; i++){
                if (result[Index-1][i]) {
                    // 不放进背包
                    result[Index][i] = true
                    // 放进背包
                    if(things_list[Index] + total_load <= max) {
                        result[Index][i + things_list[Index]] = true
                    }
                }
            }
        }

        for (let i = max; i>=0; i--) {
            if (result[n-1][i]) {return i}
        }
    }
    const a = put_thing(1,0, max, n, result)
    console.log(a)
}
bag_dynamic(10, [2,2,3,1,11])
```
这样就省去了递归的过程, 但是如何去发现这个规律就需要去从一开始进行分析, 列出像上图一样的表.也可以只用一个表来表示.
 