如何利用朴素贝叶斯算法过滤垃圾短信?

1 基于黑名单的过滤器

维护一个骚扰电话和垃圾短信发送好嘛的黑名单, 使用散列表, 二叉树进行储存, 对内存的消耗不会很大, 假设号码为16字节, 50万个号码也就差不多8MB, 即使对手机这样内存敏感的设备来说也可以接受.但是问题在于如果黑名单中的电话号码很多呢? 比如有500w 个, 这是就需要差不多80MB 的空间了. 比较大了.布隆过滤器比较省内存, 来看看能不能用它解决.500w 个大概需要5000w 大小的二进制位图, 那么需要6.25MB, 比散列表内存消耗少很多.

还有一种时间换空间的办法, 将内存的消耗优化到极致, 将黑名单放在服务器上, 发送请求去检测即可.不消耗手机任何的内存.

2 基于规则的过滤器

通过短信的内容判断某条短信是否是垃圾短信.

1. 是否包含特殊单词, 非法, 淫秽, 反动词语.
2. 号码是群发号码
3. 包含回拨方式, 比如手机号码, 微信, qq, 网络连接等
4. 格式花哨, 内容长.
5. 符合已知的垃圾短信的模板.

可以在满足上述条件的两条及以上的情况再判定为垃圾短信.

不过哪些单词属于特殊单词呢?

这就需要大量的样本数据, 也就是大量的短信, 比如有1千万条, 每条短信做好了标记, 是垃圾短信还是非垃圾短信.

然后对这1千万条短信进行粉刺,得到 n 个不同的单词, 统计多少个垃圾短信出现了这个单词, 进而求出每个单词在垃圾短信中出现的概率以及出现在非垃圾短信中的概率. 如果在垃圾短信中的概率远远大于非垃圾短信的概率, 那么就将这个词语设置为特殊单词, 用来过滤垃圾短信.

![](/img/probability.jpeg)

3 基于概率统计的过滤器

方案二有一定局限性, 规则受人的思维方式局限, 垃圾短信发送者可能针对规则精心设计短信, 绕过规则的拦截.所以再看看这个方法

这里使用到了朴素贝叶斯算法, 即P(A|B) = P(B|A)*P(A)/P(B)

同样也需要像方案二那样进行分词, 然后把短信抽象成方便计算的特征项, 用这一组特征项代替短信本身.不像方案二那样非黑即白, 而是有一定的概率

P(短信是垃圾短信|W1,W2,W3....Wn同时出现在一条短信) = P(W1,W2,W3....Wn同时出现在一条短信|短信是垃圾短信) * P(短信是垃圾短信) / P(W1,W2,W3....Wn同时出现在一条短信) 

P(W1,W2,W3....Wn同时出现在一条短信|短信是垃圾短信) = P(W1出现在短信中|短信是垃圾短信) * P(W2出现在短信中|短信是垃圾短信) * ...* P(Wn出现在短信中|短信是垃圾短信)

P(短信是垃圾短信) 可以通过样本的垃圾短信数量/总样本数

P(W1,W2,W3....Wn同时出现在一条短信)并不好求, 因为有可能样本中根本不存在这种同时出现的情况, 但是并不是非要求这个值不可, 而是可以通过计算包含这些词不是垃圾短信的概率来比较, 如果是垃圾短信的概率远远大于不是垃圾短信的概率(10倍), 那么就可以判定为垃圾短信了. 即:

P(短信**不是**垃圾短信|W1,W2,W3....Wn同时出现在一条短信) = P(W1,W2,W3....Wn同时出现在一条短信|短信**不是**垃圾短信) * P(短信**不是**垃圾短信) / P(W1,W2,W3....Wn同时出现在一条短信) 

同样的P(W1,W2,W3....Wn同时出现在一条短信|短信**不是**垃圾短信) * P(短信**不是**垃圾短信) = P(W1出现在短信中|短信**不是**垃圾短信) * P(W2出现在短信中|短信**不是**垃圾短信) * ...* P(Wn出现在短信中|短信**不是**垃圾短信)

一除就可以把P(W1,W2,W3....Wn同时出现在一条短信)消掉了.

每一种办法都有可能导致垃圾短信的误判, 可以将三者结合起来, 如果三者都判定为垃圾短信那么才为垃圾短信, 这样误判的几率会小很多.