数据库索引是如何实现的呢? 使用的是什么数据结构和算法呢?

根据某个值查找数据:
select * from user where id=1234;

根据某个区间查找某些数据
select * from user where id>1234 and id<2345

除了这些功能性需求, 还有些非功能性需求, 比如安全, 性能, 用户体验等.下面主要考虑性能方面, 也就是执行效率(时间)和储存空间(空间).

执行效率方面, 希望通过索引, 使查找效率尽可能高, 而且不消耗太多的内存.

支持快速插入和查询的动态数据结构有散列表, 平衡二叉树, 跳表

散列表很难进行区间查询, pass
平衡二叉查找树, 区间查询的成本高, pass
跳表是在链表之上的多层索引, 支持快速插入, 查找和删除.对应的时间复杂度是 logn, 天生支持区间查找

![](/img/jump_table.jpeg)

B+树很类似与跳表. 不过是通过二叉查找树演化而来的, 而不是跳表.

### 改造二叉查找树

树中的节点不储存数据本身, 只是作为索引,然后将每个叶子节点串在一条链表上,链表中的数据是从小到大有序的.

![](/img/B_plus.jpeg)

改造之后, 要求某个区间的数据, 只需要拿起始值在树中进行查找, 当查找到某个叶子节点之后, 顺着链表遍历, 直到结点值大于终止值为止.

![](/img/B_plus_1.jpeg)

不过如果储存的结点数很大, 比如有1亿个结点, 每个结点大约占用和16字节, 那么就需要大约1.6GB的内存空间, 如果需要10张表建立索引, 那么对内存的需求肯定是无法满足的. 所以就可以用时间换空间的思路, 把数据存储在硬盘中, 硬盘的读取速度通常在毫秒级, 而内存为纳秒级.因为读取速度降低了, 所以应尽量少的进行硬盘的 IO 操作, 也就是尽量降低树的高度.

如果对16个数据构建二叉树索引, 那么高度为 log<sub>2</sub>16 = 4.但是如果是构建5叉树呢?log<sub>5</sub>16 取整后高度就只有2了.

![](/img/binary_B.jpeg)

![](/img/fifth_B.jpeg)

如果是 m 叉树呢? 1亿个数的高度为 log<sub>m</sub>1*10<sup>5</sup>, 如果 m=100, 那么高度也就是3., 磁盘 IO 变少了, 查询的效率就高了

但是 m 并不是越大越好, 不管是内存中的数据, 还是磁盘中的数据, 操作系统都是按页(一页的大小通常为4KB), 一次读取会读一页的数据, 如果读取数据超过一页的大小, 就会触发多次 IO 操作, 所以在选择 m 大小时, 尽量让每个结点的大小等于一页的大小.读取一个节点, 只需要一次磁盘 IO 操作最好.

![](/img/page_size.jpeg)

```js
// 这是 B+树非叶子节点的定义, 假设 keywords=[3,5,8,10], 4个见分5个区间 children[0],...children[4]

// m 值是事先计算得到的, 依据是让所有信息的大小正好等于页的大小.PAGE_SIZE = (m-1)*(keywords的大小=4) + m*(children 的大小=8, 也就是引用, 指针占的内存大小)

class BPlusTreeNode {
  cosntructor() {
    this.m = 5;//5叉树
    this.keywords = [];//键值, 用来划分数据区间
    this.children = [];// 保存子节点的指针 
  }
}

// 这是 B+树中叶子节点的定义, 叶子节点跟内部节点是不一样的, 叶子节点储存的是值, 而不是区间, 这个定义里, 每个叶子节点储存3个数据行的键值和地址信息

// k 也是事先计算好的, 为了满足在一页内读取的目的, PAGE_SIZE=k*(keywords的大小=4)+k*(dataAddress 的大小=8)+k*(前驱指针 prev=8)+k*(后驱指针 next=8)

class BPlusTreeLeafNode {
  constructor() {
    this.k = 3
    this.keywords = []//数据的键值
    this.dataAddress=[]//数据的地址
    this.prev = new BPlusTreeLeafNode()// 前驱节点
    this.next = new BPlusTreeLeafNode()// 后驱节点
  }
}
```

索引也是有弊端的, 是方便查询了, 但是删除和插入会变慢, 比如m 给定后, 在插入及诶单后, 可能会导致子节点数超过 m, 这样就需要分裂成两个节点, 一直需要检查到根节点.

![](/img/insert_Bplus.jpeg)

删除的时候会因为某些结点中子节点的个数变得非常少, 会影响索引的效率. 可以设置一个阈值, 在 B+树中, 阈值等于 m/2, 如果某个节点的子节点数量小于 m/2, 就将他跟相邻的兄弟节点合并, 但也许合并之后的节点的子节点个数会超过 m, 可以借助插入数据时候的方法进行分裂节点

![](/img/devide_Bplus.jpeg)

总结 B+树的特点:
- 每个结点中子节点的数量不能超过 m, 不能少于 m/2
- 根节点的子节点个数不可以超过 m/2
- m 叉树只存储索引, 并不真正存储数据
- 通过链表将叶子节点串联起来, 方便按区间查找(双向链表)
- 一般情况, 根节点会被储存在内存中,其他节点储存在磁盘中

还有一个 B 树

- B+树的节点不储存数据, 只是索引, B 树储存数据
- B 树中的叶子节点不需要链表春联

也就是说, B 树只是一个每个结点的子节点个数不能少于 m/2, 不能大于 m 的 m 叉树.

